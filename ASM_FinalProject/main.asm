INCLUDE Irvine32.inc
INCLUDELIB kernel32.lib

; 定義常數
playerSize = 1
gravity = 1
jumpForce = 4

.data
; 玩家資料
player BYTE 'P'
playerAttributes WORD playerSize DUP(0bh)
playerXY COORD <10,5>
velocityY SWORD 0
isRunning BYTE 0

; 用於讀取畫面上的字符
platformBuffer BYTE 10 DUP(?)
platformCoord COORD <0,0>
charRead DWORD ?

; 用於繪製玩家和金幣的字符
outputHandle DWORD 0
bytesWritten DWORD 0
count DWORD 0

; 用於平台相關的判斷
platformLevel WORD 24
onPlatform BYTE 1

; 用於判斷是否進入結算畫面
escConfirm byte 0

; 每次更新GameLoop的時間間隔
updateInterval WORD 50 

; 用於計算和顯示時間
startTime DWORD ?
elapsedTime DWORD ?
timeLimit DWORD 600 ; 600 seconds
TimerXY COORD <0,0>

; 關卡相關資料
currentLevel DWORD 1
isCheatKeyPressed BYTE 0

;畫面繪製
fileHandle HANDLE ?
bytesRead DWORD ?
screenBytesWritten DWORD ?

;遊戲畫面資料
gameScreenFile BYTE 'gamefield1.txt',0

;初始畫面資料
buffer BYTE 7000 DUP(?)
beginScreenFile BYTE 'start.txt',0
beginKeyPos Byte 0
beginConfirm Byte 0

;初始畫面開始按鍵箭頭資料
beginStartLeftPos COORD <49,17>
beginStartLeftSymbol DWORD '>',0
beginStartRightPos COORD <73,17>
beginStartRightSymbol DWORD '<',0

;初始畫面離開按鍵箭頭資料
beginExitLeftPos COORD <49,23>
beginExitLeftSymbol DWORD '>',0
beginExitRightPos COORD <73,23>
beginExitRightSymbol DWORD '<',0

againConfirm BYTE 0

;結算畫面資料
endScreenFile BYTE 'finish.txt',0
endKeyPos Byte 0
endCoinGot DWORD 0
endTime DWORD 0
needsRefresh BYTE 1
isDead BYTE 0
prevKeyPos BYTE 0

endStartLeftPos COORD <30,20>
endStartLeftSymbol DWORD '>',0
endStartRightPos COORD <55,20>
endStartRightSymbol DWORD '<',0

endExitLeftPos COORD <68,20>
endExitLeftSymbol DWORD '>',0
endExitRightPos COORD <93,20>
endExitRightSymbol DWORD '<',0
endCoinGotCoord COORD <43,7>
endTimeCoord COORD <43,4>

;金幣生成資料
coinSeed DWORD 1
coinCoord COORD <0,0>
coinGenerated byte 0
coinSymbol byte '$'
coinAttribute WORD 0Eh
coinGot DWORD 0
coinGotCoord COORD <7,2>
coinGet byte 0
seed DWORD ?
preSeed DWORD 0

.code
	SetConsoleOutputCP PROTO STDCALL :DWORD
	GetAsyncKeyState PROTO STDCALL :DWORD
	ReadConsoleOutputCharacterA PROTO STDCALL :DWORD, :PTR BYTE, :DWORD, :COORD, :PTR DWORD
	drawScreen PROTO screenFileName :PTR BYTE

; 主程式
main PROC
	; Get the console ouput handle
	INVOKE GetStdHandle, STD_OUTPUT_HANDLE
	mov outputHandle, eax	; save console handle

; 開始介面
beginLoop:
	call Clrscr
	call displayBeginScreen
	call readInputBeginScreen
	cmp beginConfirm, 1
	je initialize
	jmp beginLoop

; 初始化遊戲
initialize:
	INVOKE GetTickCount
	mov startTime, eax
	mov playerXY.X, 10
	mov playerXY.Y, 5
	mov velocityY, 0
	mov currentLevel, 1
	mov gameScreenFile[9], '1'
	mov isDead, 0
	mov escConfirm, 0
	mov againConfirm, 0
	mov coinGot, 0
	mov coinGenerated, 0
	
; 遊戲迴圈
GameLoop:
	call Clrscr
	call updatePhysics					;重力系統
	INVOKE drawScreen, ADDR gameScreenFile	
	call drawPlayer						
	call checkPlatformLevel				;確認目前平台的Y座標
	call displayTime	
	call displayCoinGot					;顯示已獲得金幣
	call readPlayerMoveInput			
	call getCoin						;判斷是否取得金幣
	call generateCoins					
	call cheatInput						;按C鍵進入下一關
	call updateLevel					;確認以及進入下一關
	call endGame						;判斷是否觸發結束遊戲
	cmp  escConfirm, 1					
	je Refresh							
	invoke Sleep, updateInterval
	jmp GameLoop

; 結算畫面
endLoop:
	cmp needsRefresh, 1					;判斷是否刷新畫面，避免生成的數字持續閃爍
	je Refresh
	jmp CheckInput

; 更新結算畫面
Refresh:
	call Clrscr
	call displayEndScreen
	call displayEndData
	mov needsRefresh, 0
;確認變動
CheckInput:
	call readInputEndScreen
	cmp againConfirm, 1					;確認重新遊戲
	je initialize
	mov al, endKeyPos					
	mov ah, prevKeyPos
	cmp ah, al							;判斷按鍵位置，用於確認是否需要刷新畫面
	je SkipRefresh					
	mov needsRefresh, 1
	mov ah, endKeyPos
	mov prevKeyPos, ah
;跳過刷新
SkipRefresh:
	invoke Sleep, updateInterval
	jmp endLoop

	exit
main ENDP

; 更新重力和玩家位置
updatePhysics PROC uses eax ebx
	; 檢查是否超出螢幕上方
	.IF playerXY.Y >= 60000
		mov playerXY.Y, 0
		mov platformLevel, 0
	.ENDIF

	; 檢查是否掉出螢幕下方
	.IF playerXY.Y >= 26
		mov isDead, 1
	.ENDIF
    ; 更新玩家的 Y 座標
    mov ax, velocityY
    add playerXY.Y, ax        ; 根據垂直速度更新位置

    ; 應用重力（加速垂直速度）
    add velocityY, gravity    ; 重力影響：速度越來越快

    ; 檢查是否低於地面
    mov ax, playerXY.Y
    cmp ax, platformLevel
	jle EndPhysics            ; 如果未超過地面，跳過地面處理

    ; 如果超出地面，重置到地面
    mov ax, platformLevel
    mov playerXY.Y, ax        ; 將玩家重置到地面
    mov velocityY, 0          ; 停止垂直運動
    mov onPlatform, 1           ; 標記玩家在地面上
    jmp EndPhysics

EndPhysics:
    ret
updatePhysics ENDP

; 檢查平台高度
checkPlatformLevel PROC uses eax ebx ecx edx
	mov ax, playerXY.X
	mov bx, playerXY.Y
	inc bx
	mov platformCoord.X, ax
	mov platformCoord.Y, bx

	mov cx, 30

; 從玩家位置向下尋找平台
detectPlatform:
	mov dx, cx

	; 讀取螢幕上的字符
	INVOKE ReadConsoleOutputCharacterA,
	outputHandle,
	ADDR platformBuffer,
	1,
	platformCoord,
	ADDR charRead

	; 檢查是否為平台(空白之外的字符)
	mov al, platformBuffer
	.IF al != 32 ; 如果不是空白
		mov ax, platformCoord.Y
		dec ax
		mov platformLevel, ax
		jmp EndCheck
	.ENDIF
	inc platformCoord.Y
	mov cx, dx
	loop detectPlatform

EndCheck:
	ret
checkPlatformLevel ENDP

; 讀取玩家移動輸入
readPlayerMoveInput PROC
    ; 檢查W鍵（向上移動）
    INVOKE GetAsyncKeyState, 'W'
    test ax, 8000h
    jz CheckShift
	cmp onPlatform, 1
	jne CheckShift
	mov ax, jumpForce
	sub velocityY, ax
	mov onPlatform, 0
CheckShift:
	; 檢查Shift鍵（加速）
	mov isRunning, 0
	INVOKE GetAsyncKeyState, VK_SHIFT
	test ax, 8000h
	jz CheckA
	mov isRunning, 1
CheckA:
    ; 檢查A鍵（向左移動）
    INVOKE GetAsyncKeyState, 'A'
    test ax, 8000h
    jz CheckD
    .IF isRunning == 1
		sub playerXY.X, 2
	.ELSE
		dec playerXY.X
	.ENDIF
	
	; 檢查是否超出邊界左側
	.IF playerXY.X <= 0
		mov playerXY.X, 1
	.ENDIF

CheckD:
    ; 檢查D鍵（向右移動）
    INVOKE GetAsyncKeyState, 'D'
    test ax, 8000h
    jz CheckESC
    .IF isRunning == 1
		add playerXY.X, 2
	.ELSE
		inc playerXY.X
	.ENDIF

	; 檢查是否超出邊界右側
	.IF playerXY.X >= 119
		mov playerXY.X, 118
	.ENDIF

CheckESC:
    ; 檢查ESC鍵（退出遊戲）
    INVOKE GetAsyncKeyState, VK_ESCAPE
    test ax, 8000h
    jz EndInput
    mov escConfirm,1

EndInput:
	ret
readPlayerMoveInput ENDP

; 繪製玩家
drawPlayer PROC
	INVOKE WriteConsoleOutputAttribute,
	outputHandle, 
	OFFSET playerAttributes,
	playerSize, 
	playerXY,
	OFFSET count

	INVOKE WriteConsoleOutputCharacter,
	outputHandle,
	OFFSET player,
	playerSize,
	playerXY,
	OFFSET count
	ret
drawPlayer ENDP

; 繪製畫面
drawScreen PROC uses eax ebx ecx edx, screenFileName:PTR BYTE
    ;打開文字檔案
	INVOKE CreateFile, screenFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL 
	mov fileHandle, eax

ReadLoop:
	;使用UTF-8編碼，顯示符號
	INVOKE SetConsoleOutputCP, 65001

	;讀取檔案
	INVOKE ReadFile, fileHandle, ADDR buffer, SIZEOF buffer, ADDR bytesRead, NULL

	;畫面更新及輸出檔案
	call Clrscr
	INVOKE SetFilePointer, fileHandle, 0, NULL, FILE_BEGIN
	INVOKE WriteConsole, outputHandle, ADDR buffer, bytesRead, ADDR screenBytesWritten, NULL

EndDraw:
	;關閉檔案
    INVOKE CloseHandle, fileHandle
    ret
drawScreen ENDP

; 更新關卡
updateLevel PROC
	.IF coinGot == 5 && currentLevel == 1
		mov currentLevel, 2
		mov gameScreenFile[9], '2'
		mov playerXY.X, 10
		mov playerXY.Y, 5
		mov velocityY, 0
		mov coinGenerated,0
	.ELSEIF coinGot == 8 && currentLevel == 2
		mov currentLevel, 3
		mov gameScreenFile[9], '3'
		mov playerXY.X, 10
		mov playerXY.Y, 5
		mov velocityY, 0
		mov coinGenerated,0
	.ENDIF

updateLevel ENDP

; 顯示剩餘時間
displayTime PROC uses eax ebx ecx edx
	INVOKE GetTickCount
	sub eax, startTime
	cdq
	mov ebx, 1000
	div ebx
	mov elapsedTime, eax
	mov eax, timeLimit
	sub eax, elapsedTime
	mov endTime, eax
	mov dl, 6
	mov dh, 1
	call gotoxy
	call WriteDec
	ret
displayTime ENDP

;顯示初始畫面
displayBeginScreen PROC uses eax ebx ecx edx
    INVOKE drawScreen, ADDR beginScreenFile
	cmp beginKeyPos, 1
	je Pos2 
;繪製箭頭(指向start鍵)
Pos1:
	INVOKE WriteConsoleOutputCharacter,
	outputHandle, 
	OFFSET beginStartLeftSymbol,
	1, 
	beginStartLeftPos,
	OFFSET count

	INVOKE WriteConsoleOutputCharacter,
	outputHandle, 
	OFFSET beginStartRightSymbol,
	1, 
	beginStartRightPos,
	OFFSET count
	jmp conti
;繪製箭頭(指向exit鍵)
Pos2:
	INVOKE WriteConsoleOutputCharacter,
	outputHandle, 
	OFFSET beginExitLeftSymbol,
	1, 
	beginExitLeftPos,
	OFFSET count

	INVOKE WriteConsoleOutputCharacter,
	outputHandle, 
	OFFSET beginExitRightSymbol,
	1, 
	beginExitRightPos,
	OFFSET count

conti:
	INVOKE Sleep, updateInterval

EndDisplay:
    ret
displayBeginScreen ENDP

; 讀取初始畫面輸入
readInputBeginScreen PROC uses eax ebx ecx edx
;檢查Enter鍵
checkEnter:
	INVOKE GetAsyncKeyState, VK_RETURN
	test eax, 8000h                     
    jz checkW
	cmp beginKeyPos, 0 ;判斷按鍵位置
	je confirm
	call Clrscr
	INVOKE ExitProcess, 0
;開始遊戲
confirm:
	mov beginConfirm, 1
	ret
;檢查W鍵(指向start鍵)
checkW:
	INVOKE GetAsyncKeyState, 'W'
	test eax, 8000h                     
    jz checkS
	mov beginKeyPos, 0
	ret
;檢查S鍵(指向exit鍵)
checkS:
	INVOKE GetAsyncKeyState, 'S'
	test eax, 8000h                     
    jz no_key_pressed
	mov beginKeyPos, 1
	ret

no_key_pressed:
	ret
readInputBeginScreen ENDP

; 顯示結算畫面
displayEndScreen PROC uses eax ebx ecx edx
    INVOKE drawScreen, ADDR endScreenFile
	cmp endKeyPos, 1
	je Pos2 
;繪製箭頭(指向again鍵)
Pos1:
	INVOKE WriteConsoleOutputCharacter,
	outputHandle, 
	OFFSET endStartLeftSymbol,
	1, 
	endStartLeftPos,
	OFFSET count

	INVOKE WriteConsoleOutputCharacter,
	outputHandle, 
	OFFSET endStartRightSymbol,
	1, 
	endStartRightPos,
	OFFSET count
	jmp conti
;繪製箭頭(指向exit鍵)
Pos2:
	INVOKE WriteConsoleOutputCharacter,
	outputHandle, 
	OFFSET endExitLeftSymbol,
	1, 
	endExitLeftPos,
	OFFSET count

	INVOKE WriteConsoleOutputCharacter,
	outputHandle, 
	OFFSET endExitRightSymbol,
	1, 
	endExitRightPos,
	OFFSET count

conti:
	INVOKE Sleep, updateInterval

EndDisplay:
    ret
displayEndScreen ENDP

; 讀取結算畫面輸入
readInputEndScreen PROC uses eax ebx ecx edx
;檢查Enter鍵
checkEnter:
	INVOKE GetAsyncKeyState, VK_RETURN
	test eax, 8000h                     
    jz checkA
	cmp endKeyPos, 0 ;判斷按鍵位置
	je confirm
	call Clrscr
	INVOKE ExitProcess, 0
;重新遊戲
confirm:
	mov againConfirm, 1
	ret
;檢查W鍵(指向again鍵)
checkA:
	INVOKE GetAsyncKeyState, 'A'
	test eax, 8000h                     
    jz checkD
	mov endKeyPos, 0
	ret
;檢查S鍵(指向exit鍵)
checkD:
	INVOKE GetAsyncKeyState, 'D'
	test eax, 8000h                     
    jz no_key_pressed
	mov endKeyPos, 1
	ret

no_key_pressed:
	ret
readInputEndScreen ENDP

; 生成金幣
generateCoins PROC uses eax ebx ecx edx
;判斷關卡數
	cmp coinGenerated, 1
	je output
	cmp currentLevel, 2
	je Level2
	cmp currentLevel, 3
	je Level3

;第一關
Level1:
	call generateRandomSeed
	cmp coinSeed, 0
	je Pos1_1
	cmp coinSeed, 1
	je Pos1_2
	cmp coinSeed, 2
	je Pos1_3
	jmp Pos1_4

Pos1_1:
	mov coinCoord.x, 15
	mov coinCoord.y, 3
	jmp output

Pos1_2:
	mov coinCoord.x, 90
	mov coinCoord.y, 4
	jmp output

Pos1_3:
	mov coinCoord.x, 40
	mov coinCoord.y, 14
	jmp output

Pos1_4:
	mov coinCoord.x, 98
	mov coinCoord.y, 15
	mov coinSeed, 0
	jmp output

;第二關
Level2:
	call generateRandomSeed
	cmp coinSeed, 0
	je Pos2_1
	cmp coinSeed, 1
	je Pos2_2
	cmp coinSeed, 2
	je Pos2_3
	jmp Pos2_4
	
Pos2_1:
	mov coinCoord.x, 29
	mov coinCoord.y, 3
	jmp output

Pos2_2:
	mov coinCoord.x, 55
	mov coinCoord.y, 15
	jmp output

Pos2_3:
	mov coinCoord.x, 114
	mov coinCoord.y, 4
	jmp output

Pos2_4:
	mov coinCoord.x, 78
	mov coinCoord.y, 11
	mov coinSeed, 0
	jmp output

;第三關
Level3:
	call generateRandomSeed
	cmp coinSeed, 0
	je Pos3_1
	cmp coinSeed, 1
	je Pos3_2
	cmp coinSeed, 2
	je Pos3_3
	jmp Pos3_4

Pos3_1:
	mov coinCoord.x, 71
	mov coinCoord.y, 1
	jmp output

Pos3_2:
	mov coinCoord.x, 8
	mov coinCoord.y, 9
	jmp output

Pos3_3:
	mov coinCoord.x, 103
	mov coinCoord.y, 8
	jmp output

Pos3_4:
	mov coinCoord.x, 52
	mov coinCoord.y, 14
	jmp output

;顯示金幣
output:
	INVOKE WriteConsoleOutputCharacter,
	outputHandle,
	OFFSET coinSymbol,
	1,
	coinCoord,
	OFFSET count

	INVOKE WriteConsoleOutputAttribute,
	outputHandle, 
	OFFSET coinAttribute,
	1, 
	coinCoord,
	OFFSET count

	mov coinGenerated, 1
	ret
generateCoins ENDP

; 顯示金幣數量
displayCoinGot PROC uses eax ebx ecx edx
    invoke SetConsoleCursorPosition,outputHandle, coinGotCoord
	mov eax, coinGot
	call WriteDec
	ret
displayCoinGot ENDP

; 快速通關鈕
cheatInput PROC
	INVOKE GetAsyncKeyState, 'C'
	test eax, 8000h
	jz notPressed
	.IF isCheatKeyPressed == 0
		.IF currentLevel == 1
			mov coinGot, 5
		.ELSEIF currentLevel == 2
			mov coinGot, 8
		.ELSEIF currentLevel == 3
			mov coinGot, 12
		.ENDIF
		mov isCheatKeyPressed, 1
	.ENDIF
	ret
	
notPressed:
	mov isCheatKeyPressed, 0
	ret
cheatInput ENDP

; 顯示結算資訊
displayEndData PROC uses eax ebx ecx edx
coin:
	mov dl, 43
	mov dh, 7
	call gotoxy
	mov eax, CoinGot
	call WriteDec

time:
	mov dl, 43
	mov dh, 4
	call gotoxy
	mov eax, endTime
	call WriteDec

point:
	mov dl, 43
	mov dh, 10
	call gotoxy
	.IF isDead == 1
		.IF currentLevel == 1
			mov eax, 0
		.ELSEIF currentLevel == 2
			mov eax, 5
		.ELSEIF currentLevel == 3
			mov eax, 8
		.ENDIF
	.ELSE
		mov eax, coinGot
	.ENDIF
	mul endTime
	call WriteDec

level:
	mov dl, 43
	mov dh, 13
	call gotoxy
	mov eax, currentLevel
	.IF isDead == 1
		dec eax
	.ENDIF
	call WriteDec
	
	mov dl, 0
	mov dh, 0
	call gotoxy
	ret
displayEndData ENDP

; 判斷是否取得金幣
getCoin PROC uses eax ebx ecx edx
;判斷X座標
compareX:
	mov ax, playerXY.x
	cmp ax, coinCoord.x
	jne not_equal

;判斷Y座標
compareY:
	mov ax, playerXY.y
	cmp ax, coinCoord.y
	jne not_equal

;兩者皆相同的情況
equal:
	mov coinGet, 1
	inc coinGot
	mov coinGenerated, 0
	jmp end_program

not_equal:
	mov coinGet, 0

end_program:
	ret

getCoin ENDP

; 判斷遊戲是否結束
endGame PROC uses eax ebx ecx edx
	;獲得12枚金幣
	mov eax, coinGot
	cmp eax, 12
	je equal

	;時間結束
	mov eax, endTime
	cmp eax, 0
	je equal

	;掉入洞裡死亡
	mov al, isDead
	cmp al, 1
	je equal
	jmp end_program

equal:
	mov escConfirm, 1

end_program:
	ret
endGame ENDP

; 計算用於生成金幣的隨機種子
generateRandomSeed PROC uses eax ebx ecx edx
generate:
	;取得總計執行時間，作為隨機數使用
	invoke GetTickCount

	;處理所得時間，最後得到0~3的隨機整數
    imul eax, 214013    
    add eax, 2531011
    shr eax, 16    
    and eax, 7FFFh
    xor edx, edx
	mov ebx, 5
    div ebx    
    mov coinSeed, edx

	;判斷與前一次生成位置是否相同，避免重複位置生成
	cmp edx, preSeed
	je generate
	mov preSeed,edx
	
	ret
generateRandomSeed ENDP

END main